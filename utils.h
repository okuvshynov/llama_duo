#pragma once

#include <string>
#include <iostream>
#include <vector>
#include <queue>
#include <cstdio>
#include <ctime>
#include <cstdarg>

// llama.cpp
#include <llama.h>
#include <common.h>

namespace llama_duo
{

// debug visualization utils for tokens which were:
//  - matched - generated by both models
//  - rejected - produced by speculation model and did not match
//  - not_matched - produced by main model (and accepted) but not matched with speculation model.
// after each print we swap the bold marker
// to get visual boundaries of token sequences 
// processed in one iteration

void dbg_color(const std::string & s, const std::string & fg)
{
    static const std::string kReset = "\033[0m";
    static const std::string bold[] = { "", "\033[1m" };
    static size_t index = 0;
    std::cout << bold[index] << fg << s << kReset << std::flush;
    index = 1 - index;
}

void dbg_accepted(const std::string & accepted)
{
    static const std::string kGreen = "\033[32m";
    dbg_color(accepted, kGreen);
}

void dbg_not_matched(const std::string & accepted)
{
    dbg_color(accepted, "");
}

void dbg_rejected(const std::string & rejected)
{
    static const std::string kRed = "\033[31m";
    dbg_color(rejected, kRed);
}

template<typename iter_t>
std::string to_string(llama_context * ctx, iter_t from, iter_t to)
{
    std::string res = "";
    for (auto it = from; it != to; ++it)
    {
        res += llama_token_to_piece(ctx, *it);
    }
    return res;
}

std::vector<llama_token> greedy_tokens(
        llama_model * model,
        llama_context * ctx,
        int32_t from_idx,
        int32_t to_idx)
{
    auto n_vocab = llama_n_vocab(model);
    std::vector<llama_token> res;
    if (n_vocab <= 0)
    {
        return res;
    }

    for (int idx = from_idx; idx < to_idx; idx++)
    {
        auto * logits  = llama_get_logits_ith(ctx, idx);
        llama_token new_token_id = 0;
        for (llama_token token_id = 1; token_id < n_vocab; token_id++)
        {
            if (logits[token_id] > logits[new_token_id])
            {
                new_token_id = token_id;
            }
        }

        res.push_back(new_token_id);
    }
    return res;
}

// not very efficient implementation
template<typename iter_t>
uint32_t crc32(iter_t begin, iter_t end)
{
    uint32_t crc = 0xFFFFFFFF;
    for (auto it = begin; it != end; ++it)
    {
        const auto val = *it; 
        const uint8_t * bytes = reinterpret_cast<const uint8_t*>(&val);
        for (uint32_t i = 0; i < sizeof(val); ++i)
        {
            crc = crc ^ bytes[i];
            for (uint32_t j = 0; j < 8; j++)
            {
                if (crc & 1)
                    crc = (crc >> 1) ^ 0xEDB88320;
                else
                    crc = crc >> 1;
            }
        }
    }
    return ~crc;
}

struct value_parser
{
    template<typename value_t>
    static void parse(const char * value, value_t & field)
    {
        std::istringstream iss(value);
        iss >> field;
    }
};

template<>
void value_parser::parse<std::string>(const char * value, std::string & field)
{
    field = value;
}

// simple and not very efficient option parser
template<typename config_t>
struct parser
{
    int parse_options(int argc, char ** argv, config_t & conf)
    {
        for (int i = 1; i < argc; i++)
        {
            std::string key(argv[i]);
            auto it = setters_.find(key);
            if (it != setters_.end())
            {
                if (++i < argc)
                {
                    it->second(argv[i], conf);
                }
                else
                {
                    fprintf(stderr, "No argument value provided for %s\n", argv[i - 1]);
                    return 1;
                }
            }
            else
            {
                fprintf(stderr, "Unknown argument %s\n", argv[i]);
                return 1;
            }
        }
        return 0;
    }

    template<typename T>
    void add_option(const std::string& key, T config_t::* field)
    {
        setters_[key] = [field](const char * value, config_t & conf)
        {
            value_parser::parse(value, conf.*field);
        };
    }

    template<typename T>
    void add_option(const std::initializer_list<std::string>& keys, T config_t::* field)
    {
        for (const auto& key : keys)
        {
            add_option(key, field);
        }
    }

  private:
    std::map<std::string, std::function<void(const char*, config_t&)>> setters_;
};


class log
{
  public:
    static void fatal(const char* format, ...)
    {
        va_list args;
        va_start(args, format);
        inst().write(FATAL, format, args);
        va_end(args);
    }

    static void error(const char* format, ...)
    {
        va_list args;
        va_start(args, format);
        inst().write(ERROR, format, args);
        va_end(args);
    }

    static void warn(const char* format, ...)
    {
        va_list args;
        va_start(args, format);
        inst().write(WARN, format, args);
        va_end(args);
    }

    static void info(const char* format, ...)
    {
        va_list args;
        va_start(args, format);
        inst().write(INFO, format, args);
        va_end(args);
    }

    static void debug(const char* format, ...)
    {
        va_list args;
        va_start(args, format);
        inst().write(DEBUG, format, args);
        va_end(args);
    }

  private:
    enum log_level
    {
        FATAL = 0,
        ERROR = 1,
        WARN  = 2,
        INFO  = 3,
        DEBUG = 4
    };
    static log& inst()
    {
        static log l;
        return l;
    }
    void write(log_level ll, const char* format, va_list args)
    {
        using namespace std::chrono;
        static std::string log_level_str[] = {"F", "E", "W", "I", "D"};

        auto now        = system_clock::now();
        auto now_time_t = system_clock::to_time_t(now);
        auto now_us     = duration_cast<microseconds>(now.time_since_epoch()) % 1000000;
        
        std::tm local;
        localtime_r(&now_time_t, &local);
        std::fprintf
        (
            stderr, 
            "%s%04d-%02d-%02d %02d:%02d:%02d.%06lld ",
            log_level_str[ll].c_str(),
            local.tm_year + 1900, local.tm_mon + 1, local.tm_mday,
            local.tm_hour, local.tm_min, local.tm_sec, now_us.count()
        );
        std::vfprintf(stderr, format, args);
        std::fprintf(stderr, "\n");
    }
};

}
